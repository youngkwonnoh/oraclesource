-- JOIN
-- 등가조인(INNER JOIN(내부조인), 단순조인)
SELECT * FROM DEPT;
SELECT * FROM EMP;

-- column ambiguously defined
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- 문장이 길어 별칭으로 만든 후 처리
SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


-- EMP 테이블의 DEPTNO와 DEPT 테이블의 DEPTNO가 일치하는 사원들의
-- 사원번호, 이름, 부서번호, 부서명 조회(단, 급여가 3000 이상인 사원 출력)
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND SAL >= 3000;

-- EMP 테이블 별칭을 E로, DEPT 테이블 별칭을 D로 하여 급여가 2500 이상이고
-- 사원번호가 9999 이하인 사원들의 정보 출력
-- EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC를 출력
SELECT EMPNO, ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL >= 2500 AND E.EMPNO <= 9999;


-- EMP 테이블 별칭을 E로, SALGRADE 테이블 별칭을 S로 하여 
-- 각 사원의 정보와 사원의 급여 등급 정보를 출력하기
SELECT * FROM SALGRADE;

-- 비등가 조인
SELECT *
FROM EMP E, SALGRADE S
WHERE SAL BETWEEN S.LOSAL AND S.HISAL;

-- 자체조인(SELF JOIN) : 조인을 할 때 두번째 테이블이 자기 자신
SELECT * FROM EMP;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

-- 외부조인
-- 왼쪽 외부 조인 WHERE TABLE1.COL1 = TABLE2.COL(+)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

-- 오른쪽 외부 조인 WHERE TABLE1.COL1(+) = TABLE2.COL
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

-- + 기호를 붙이는 외부 조인 방식은 전체 외부 조인 구현 불가
--SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
--FROM EMP E1, EMP E2
--WHERE E1.MGR(+) = E2.EMPNO(+);

-- 표준문법 조인

-- NATURAL JOIN(등가조인)
SELECT E.EMPNO, E.ENAME, DEPTNO, D.DNAME
FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO;


-- JOIN ~ ON
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, E.EMPNO;


-- 표준 JOIN 문
-- OUTER JOIN ~ ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;



-- 각 부서별 평균(급여), 최대(급여), 최소(급여), 사원수를 출력하가ㅣ
-- 단, 부서번호, 부서명, 평균, 최대, 최소, 사원수 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;

-- 표준 버전
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;


-- 모든 부서정보와 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 직무, 급여 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL 
FROM DEPT D LEFT OUTER JOIN EMP E 
ON D.DEPTNO = E.DEPTNO;


-- 급여가 2천 초과인 사원들의 부서 정보, 사원정보를 출력하기(SQL 표준 문법으로 작성)
-- 부서번호, 부서명, 사원번호, 사원명, 급여 순으로 출력
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D ON E.SAL > 2000;

-- 세 개의 테이블 조인
-- 기본 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPONO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1, EMP E2, EMP E3
WHERE E1.EMPNO = E2.EMPNO AND E2.EMPNO = E3.EMPNO;

-- 표준 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPONO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1 JOIN EMP E2 ON E1.EMPNO = E2.EMPNO JOIN EMP E2 ON E3.EMPNO = E3.EMPNO;

-- 모든 부서 정보와 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 
-- 직무, 매니저번호, 급여, LOSAL, HISAL, GRADE, 직속상관의 정보를 출력
-- 부서번호, 사원이름 순으로 오름차순 정렬

-- 오른쪽 외부 조인(RIGHT OUTER JOIN)
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO ORDER BY DEPTNO;


SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, 
    E.MGR, E.SAL, S.LOSAL, S.HISAL, S.GRADE, 
    E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
    AND E.MGR = E2.EMPNO(+) 
ORDER BY D.DEPTNO, E.ENAME;


-- 표준
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, 
    E.MGR, E.SAL, S.LOSAL, S.HISAL, S.GRADE, 
    E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
    LEFT OUTER JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
    LEFT OUTER JOIN EMP E2 ON E.MGR = E2.EMPNO
ORDER BY D.DEPTNO, E.ENAME;


-- JONES 라는 사람의 급여보다 높은 급여를 받는 사원 조회
-- 서브쿼리 사용 전
SELECT SAL FROM EMP WHERE ename = 'JONES';
SELECT * FROM EMP WHERE SAL > 2975;

-- 서브쿼리 사용 후
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ename='JONES');

-- ALLEN 사원의 추가수당보다 많은 추가수당을 받는 사원 조회
SELECT * FROM EMP WHERE COMM > (SELECT COMM FROM EMP WHERE ename='ALLEN');

-- WARD보다 빨리 입사한 사원
SELECT * FROM EMP WHERE hiredate < (SELECT hiredate FROM EMP WHERE ename='WARD');

-- 20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 급여를 받는 사원정보
-- (사원번호, 사원명, 직무, 급여)와 소속부서정보(부서번호, 부서명, 지역위치)를 조회
SELECT EMPNO, ENAME, JOB, SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND D.DEPTNO=20 AND SAL > (SELECT AVG(SAL) FROM EMP);

-- 각 부서별 최고 급여와 동일한 급여 및 큰 급여를 받는 사원 정보를 조회
-- single-row subquery returns more than one row
-- >= : 단일행 서브쿼리
SELECT * FROM EMP WHERE SAL >= (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT * FROM EMP WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 각 부서별 최고 급여와 동일한 급여 및 큰 급여를 받는 사원 정보를 조회
SELECT * FROM EMP WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
SELECT * FROM EMP WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 정보 출력하기
SELECT *
FROM EMP
WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);

SELECT *
FROM EMP
WHERE SAL < ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);

-- ANY(SOME) : 서브쿼리가 반환한 여러 결과값 중 메인 쿼리와 조건식을 사용한 결과가
-- 하나라도 일치하면 TRUE

-- 30번 부서 사원들의 최소 급여보다 많은 급여를 받는 사원 정보 출력하기
SELECT *
FROM EMP
WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);


-- ALL : 서브쿼리의 모든 결과가 조건식에 맞아 떨어져야 
-- 메인 쿼리의 조건식이 TRUE 됨
SELECT *
FROM EMP
WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);

SELECT *
FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);

-- EXISTS : 서브쿼리에 결과 값이 하나 이상 존재하면 조건식이 모두 TRUE, 존재하지 않으면 FALSE
SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=50);

SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=20);

SELECT EMPNO, DEPTNO
FROM EMP
WHERE NOT EXISTS 
(SELECT DEPTNO FROM DEPT WHERE DEPTNO IN (20, 30)
AND EMP.DEPTNO = DEPT.DEPTNO);

SELECT E.JOB, E.EMPNO, E.SAL, E.DEPTNO, D.DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
AND E.JOB IN (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

SELECT E.JOB, E.EMPNO, E.SAL, E.DEPTNO, D.DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
AND E.JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL 
                AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO ASC;

-- 다중열 서브쿼리
-- 자신의 부서 내에서 최고 연봉과 동일한 급여를 받는 사원 추출
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 서브쿼리(FROM 절에 사용하는 서브쿼리 : 인라인 뷰)
-- 특정 테이블 전체 데이터가 아닌 SELECT 문을 통해 일부 데이터를 먼저 추출해 온 후 
-- 별칭을 붙여서 사용하는 방식

SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10,
    (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = DEPTNO;

-- 서브쿼리(SELECT 절에 사용하는 서브쿼리 : 스칼라 서브쿼리)
SELECT EMPNO, ENAME, JOB, SAL, (SELECT GRADE
                                FROM SALGRADE
                                WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE,
                                DEPTNO,(SELECT DNAME
                                        FROM DEPT
                                        WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME
FROM EMP E;

SELECT EMPNO, ENAME, JOB, DEPTNO, DNAME, LOC
FROM EMP;

-- 10번 부서에 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진
-- 사원들의 사원정보, 부서 정보를 출력하는 SQL문 작성

SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.DEPTNO, D1.DNAME, D1.LOC
FROM EMP E1, DEPT D1
WHERE E1.DEPTNO = D1.DEPTNO AND E1.DEPTNO = 10 AND E1.JOB NOT IN (SELECT JOB FROM EMP WHERE DEPTNO=30);


-- 직책이 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의
-- 사원정보, 급여등급 정보를 출력하는 SQL문 작성
-- (단, 서브쿼리를 활용할 때 다중형함수를 사용하는 방법과 사용하지않는 방법을
-- 통해 사원번호를 기준으로 오름차순 정렬하여 출력)

-- 사용하지 않는 방법
SELECT EMPNO, ENAME, SAL, (SELECT GRADE FROM SALGRADE WHERE E1.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E1
WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');


-- 사용하는 방법
SELECT EMPNO, ENAME, SAL, (SELECT GRADE FROM SALGRADE WHERE E1.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E1
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');




-- 데이터 삽입
-- 테이블 복제(테이블 구조와 내용이 모두 복사)
CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP;

-- INSERT 구문 형식
INSERT INTO DEPT_TEMP VALUES(50, 'DATABASE', 'SEOUL');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP(DEPTNO, DNAME) VALUES(60, 'NETWORK');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(70, 'WEB', NULL);
-- "not enough values"
INSERT INTO DEPT_TEMP VALUES(70, 'DATABASE2');

-- value larger than specified precision allowed for this column
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(800, 'DATABASE', 'SEOUL');

-- 테이블 구조만 복제
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1;
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP VALUES(9999, '홍길동', 'PRESODENT', NULL, '2001/01/01', 4000, NULL, 10);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(1111, '성춘향', 'MANAGER', NULL, '2003-01-01', 5000, 1000, 10);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(2222, '유승호', 'MANAGER', 1111, SYSDATE, 5000, NULL, 10);

-- EMP 테이블에서 SALGRADE 테이블을 참조하여 급여 등급이 1인 사원만을 EMP_TEMP 추가
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE=1;

commit;
