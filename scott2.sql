-- JOIN
-- 등가조인(INNER JOIN(내부조인), 단순조인)
SELECT * FROM DEPT;
SELECT * FROM EMP;

-- column ambiguously defined
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- 문장이 길어 별칭으로 만든 후 처리
SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


-- EMP 테이블의 DEPTNO와 DEPT 테이블의 DEPTNO가 일치하는 사원들의
-- 사원번호, 이름, 부서번호, 부서명 조회(단, 급여가 3000 이상인 사원 출력)
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND SAL >= 3000;

-- EMP 테이블 별칭을 E로, DEPT 테이블 별칭을 D로 하여 급여가 2500 이상이고
-- 사원번호가 9999 이하인 사원들의 정보 출력
-- EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC를 출력
SELECT EMPNO, ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL >= 2500 AND E.EMPNO <= 9999;


-- EMP 테이블 별칭을 E로, SALGRADE 테이블 별칭을 S로 하여 
-- 각 사원의 정보와 사원의 급여 등급 정보를 출력하기
SELECT * FROM SALGRADE;

-- 비등가 조인
SELECT *
FROM EMP E, SALGRADE S
WHERE SAL BETWEEN S.LOSAL AND S.HISAL;

-- 자체조인(SELF JOIN) : 조인을 할 때 두번째 테이블이 자기 자신
SELECT * FROM EMP;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

-- 외부조인
-- 왼쪽 외부 조인 WHERE TABLE1.COL1 = TABLE2.COL(+)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

-- 오른쪽 외부 조인 WHERE TABLE1.COL1(+) = TABLE2.COL
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

-- + 기호를 붙이는 외부 조인 방식은 전체 외부 조인 구현 불가
--SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
--FROM EMP E1, EMP E2
--WHERE E1.MGR(+) = E2.EMPNO(+);

-- 표준문법 조인

-- NATURAL JOIN(등가조인)
SELECT E.EMPNO, E.ENAME, DEPTNO, D.DNAME
FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO;


-- JOIN ~ ON
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, E.EMPNO;


-- 표준 JOIN 문
-- OUTER JOIN ~ ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;



-- 각 부서별 평균(급여), 최대(급여), 최소(급여), 사원수를 출력하가ㅣ
-- 단, 부서번호, 부서명, 평균, 최대, 최소, 사원수 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;

-- 표준 버전
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;


-- 모든 부서정보와 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 직무, 급여 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL 
FROM DEPT D LEFT OUTER JOIN EMP E 
ON D.DEPTNO = E.DEPTNO;


-- 급여가 2천 초과인 사원들의 부서 정보, 사원정보를 출력하기(SQL 표준 문법으로 작성)
-- 부서번호, 부서명, 사원번호, 사원명, 급여 순으로 출력
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D ON E.SAL > 2000;

-- 세 개의 테이블 조인
-- 기본 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPONO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1, EMP E2, EMP E3
WHERE E1.EMPNO = E2.EMPNO AND E2.EMPNO = E3.EMPNO;

-- 표준 방식
SELECT E1.EMPNO AS EMPNO_E1, E2.EMPNO AS EMPONO_E2, E3.EMPNO AS EMPNO_E3
FROM EMP E1 JOIN EMP E2 ON E1.EMPNO = E2.EMPNO JOIN EMP E2 ON E3.EMPNO = E3.EMPNO;

-- 모든 부서 정보와 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 
-- 직무, 매니저번호, 급여, LOSAL, HISAL, GRADE, 직속상관의 정보를 출력
-- 부서번호, 사원이름 순으로 오름차순 정렬

-- 오른쪽 외부 조인(RIGHT OUTER JOIN)
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO ORDER BY DEPTNO;


SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, 
    E.MGR, E.SAL, S.LOSAL, S.HISAL, S.GRADE, 
    E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
    AND E.MGR = E2.EMPNO(+) 
ORDER BY D.DEPTNO, E.ENAME;


-- 표준
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, 
    E.MGR, E.SAL, S.LOSAL, S.HISAL, S.GRADE, 
    E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E RIGHT OUTER JOIN DEPT D ON E.DEPTNO = D.DEPTNO
    LEFT OUTER JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
    LEFT OUTER JOIN EMP E2 ON E.MGR = E2.EMPNO
ORDER BY D.DEPTNO, E.ENAME;


-- JONES 라는 사람의 급여보다 높은 급여를 받는 사원 조회
-- 서브쿼리 사용 전
SELECT SAL FROM EMP WHERE ename = 'JONES';
SELECT * FROM EMP WHERE SAL > 2975;

-- 서브쿼리 사용 후
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ename='JONES');

-- ALLEN 사원의 추가수당보다 많은 추가수당을 받는 사원 조회
SELECT * FROM EMP WHERE COMM > (SELECT COMM FROM EMP WHERE ename='ALLEN');

-- WARD보다 빨리 입사한 사원
SELECT * FROM EMP WHERE hiredate < (SELECT hiredate FROM EMP WHERE ename='WARD');

-- 20번 부서에 속한 사원 중 전체 사원의 평균 급여보다 높은 급여를 받는 사원정보
-- (사원번호, 사원명, 직무, 급여)와 소속부서정보(부서번호, 부서명, 지역위치)를 조회
SELECT EMPNO, ENAME, JOB, SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND D.DEPTNO=20 AND SAL > (SELECT AVG(SAL) FROM EMP);

-- 각 부서별 최고 급여와 동일한 급여 및 큰 급여를 받는 사원 정보를 조회
-- single-row subquery returns more than one row
-- >= : 단일행 서브쿼리
SELECT * FROM EMP WHERE SAL >= (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

SELECT * FROM EMP WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 각 부서별 최고 급여와 동일한 급여 및 큰 급여를 받는 사원 정보를 조회
SELECT * FROM EMP WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
SELECT * FROM EMP WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 정보 출력하기
SELECT *
FROM EMP
WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);

SELECT *
FROM EMP
WHERE SAL < ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);

-- ANY(SOME) : 서브쿼리가 반환한 여러 결과값 중 메인 쿼리와 조건식을 사용한 결과가
-- 하나라도 일치하면 TRUE

-- 30번 부서 사원들의 최소 급여보다 많은 급여를 받는 사원 정보 출력하기
SELECT *
FROM EMP
WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO=30);


-- ALL : 서브쿼리의 모든 결과가 조건식에 맞아 떨어져야 
-- 메인 쿼리의 조건식이 TRUE 됨
SELECT *
FROM EMP
WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);

SELECT *
FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);

-- EXISTS : 서브쿼리에 결과 값이 하나 이상 존재하면 조건식이 모두 TRUE, 존재하지 않으면 FALSE
SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=50);

SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=20);

SELECT EMPNO, DEPTNO
FROM EMP
WHERE NOT EXISTS 
(SELECT DEPTNO FROM DEPT WHERE DEPTNO IN (20, 30)
AND EMP.DEPTNO = DEPT.DEPTNO);

SELECT E.JOB, E.EMPNO, E.SAL, E.DEPTNO, D.DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
AND E.JOB IN (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

SELECT E.JOB, E.EMPNO, E.SAL, E.DEPTNO, D.DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
AND E.JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN');

SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL 
                AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, E.EMPNO ASC;

-- 다중열 서브쿼리
-- 자신의 부서 내에서 최고 연봉과 동일한 급여를 받는 사원 추출
SELECT *
FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

-- 서브쿼리(FROM 절에 사용하는 서브쿼리 : 인라인 뷰)
-- 특정 테이블 전체 데이터가 아닌 SELECT 문을 통해 일부 데이터를 먼저 추출해 온 후 
-- 별칭을 붙여서 사용하는 방식

SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO=10) E10,
    (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = DEPTNO;

-- 서브쿼리(SELECT 절에 사용하는 서브쿼리 : 스칼라 서브쿼리)
SELECT EMPNO, ENAME, JOB, SAL, (SELECT GRADE
                                FROM SALGRADE
                                WHERE E.SAL BETWEEN LOSAL AND HISAL) AS SALGRADE,
                                DEPTNO,(SELECT DNAME
                                        FROM DEPT
                                        WHERE E.DEPTNO = DEPT.DEPTNO) AS DNAME
FROM EMP E;

SELECT EMPNO, ENAME, JOB, DEPTNO, DNAME, LOC
FROM EMP;

-- 10번 부서에 근무하는 사원 중 30번 부서에는 존재하지 않는 직책을 가진
-- 사원들의 사원정보, 부서 정보를 출력하는 SQL문 작성

SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.DEPTNO, D1.DNAME, D1.LOC
FROM EMP E1, DEPT D1
WHERE E1.DEPTNO = D1.DEPTNO AND E1.DEPTNO = 10 AND E1.JOB NOT IN (SELECT JOB FROM EMP WHERE DEPTNO=30);


-- 직책이 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의
-- 사원정보, 급여등급 정보를 출력하는 SQL문 작성
-- (단, 서브쿼리를 활용할 때 다중형함수를 사용하는 방법과 사용하지않는 방법을
-- 통해 사원번호를 기준으로 오름차순 정렬하여 출력)

-- 사용하지 않는 방법
SELECT EMPNO, ENAME, SAL, (SELECT GRADE FROM SALGRADE WHERE E1.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E1
WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN');


-- 사용하는 방법
SELECT EMPNO, ENAME, SAL, (SELECT GRADE FROM SALGRADE WHERE E1.SAL BETWEEN LOSAL AND HISAL) AS GRADE
FROM EMP E1
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');




-- 데이터 삽입
-- 테이블 복제(테이블 구조와 내용이 모두 복사)
CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP;

-- INSERT 구문 형식
INSERT INTO DEPT_TEMP VALUES(50, 'DATABASE', 'SEOUL');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP(DEPTNO, DNAME) VALUES(60, 'NETWORK');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(70, 'WEB', NULL);
-- "not enough values"
INSERT INTO DEPT_TEMP VALUES(70, 'DATABASE2');

-- value larger than specified precision allowed for this column
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(800, 'DATABASE', 'SEOUL');

-- 테이블 구조만 복제
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1;
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP VALUES(9999, '홍길동', 'PRESODENT', NULL, '2001/01/01', 4000, NULL, 10);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(1111, '성춘향', 'MANAGER', NULL, '2003-01-01', 5000, 1000, 10);

INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(2222, '유승호', 'MANAGER', 1111, SYSDATE, 5000, NULL, 10);

-- EMP 테이블에서 SALGRADE 테이블을 참조하여 급여 등급이 1인 사원만을 EMP_TEMP 추가
INSERT INTO EMP_TEMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE=1;

commit;

-- update : 데이터 수정
-- update 변경할 테이블 명
-- set 변경할 열 명 = 변경할 값, 변경할 열 명 = 변경할 값, 변경할 열 명 = 변경할 값
-- where 조건(필수는 아님)

select * from dept_temp;

-- 테이블의 특정 열 값을 전체 수정
UPDATE dept_temp 
SET LOC = 'SEOUL';

-- 테이블의 특정 열 값을 조건에 맞춰 수정
UPDATE dept_temp 
SET LOC = 'SEOUL'
WHERE DEPTNO = 80;

-- COMMIT 상태로 되돌린다.
ROLLBACK;

SELECT * FROM EMP_TEMP;
-- 급여가 3천 이하인 사원만 추가수당을 50으로 변경
UPDATE EMP_TEMP
SET COMM = 50
WHERE SAL <= 3000;

-- 서브 쿼리를 사용하여 데이터 수정(select 구문 안에 select 구문이 또 들어감)
CREATE TABLE DEPT_TEMP2 AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP2;

UPDATE dept_temp2
SET (DNAME, LOC) = (SELECT DNAME, LOC
                    FROM DEPT
                    WHERE DEPTNO = 40)
WHERE DEPTNO = 30;
ROLLBACK;

UPDATE DEPT_TEMP2
SET LOC = 'SEOUL'
WHERE DEPTNO = (SELECT DEPTNO
                FROM DEPT_TEMP2
                WHERE DNAME = 'OPERATIONS');

-- DELETE : 테이블에 있는 데이터 삭제
-- DELETE 테이블명
CREATE TABLE EMP_TEMP2 AS SELECT * FROM EMP;
SELECT * FROM EMP_TEMP2;

ROLLBACK;

-- 전체 삭제 : 웬만해선 쓸일이 없다
DELETE EMP_TEMP2;

-- 부분 삭제
-- JOB이 MANAGER인 사원 삭제
DELETE FROM EMP_TEMP2
WHERE JOB = 'MANAGER';

-- 서브쿼리를 사용하여 데이터 삭제
-- 급여 등급이 3등급이고, 30번 부서의 사원만 삭제
DELETE FROM EMP_TEMP2
WHERE EMPNO IN (SELECT EMPNO
                FROM EMP_TEMP2 E, SALGRADE S 
                WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 3 AND E.DEPTNO = 30);

-- EMP_TEMP2 테이블에서 급여가 5천 이상인 사원 삭제
DELETE FROM EMP_TEMP2 WHERE SAL >= 5000;


-- PPT 5장 실습문제 1
CREATE TABLE EXAM_EMP AS SELECT * FROM EMP;
SELECT * FROM EXAM_EMP;

CREATE TABLE EXAM_DEPT AS SELECT * FROM DEPT;
SELECT * FROM EXAM_DEPT;

CREATE TABLE EXAM_SALGRADE AS SELECT * FROM SALGRADE;
SELECT * FROM EXAM_SALGRADE;

-- PPT 5장 실습문제 2

INSERT INTO EXAM_EMP VALUES(7201, 'TEST_USER1', 'MANAGER', 7788, '2016-01-02', 4500, NULL, 50);
INSERT INTO EXAM_EMP VALUES(7202, 'TEST_USER2', 'CLERK', 7201, '2016-02-21', 1800, NULL, 50);
INSERT INTO EXAM_EMP VALUES(7203, 'TEST_USER3', 'ANALYST', 7201, '2016-04-11', 3400, NULL, 60);
INSERT INTO EXAM_EMP VALUES(7204, 'TEST_USER4', 'SALESMAN', 7201, '2016-05-31', 2700, 300, 60);
INSERT INTO EXAM_EMP VALUES(7205, 'TEST_USER5', 'CLERK', 7201, '2016-07-20', 2600, NULL, 70);
INSERT INTO EXAM_EMP VALUES(7206, 'TEST_USER6', 'CLERK', 7201, '2016-09-08', 2600, NULL, 70);
INSERT INTO EXAM_EMP VALUES(7207, 'TEST_USER7', 'LECTURER', 7201, '2016-10-28', 2300, NULL, 80);
INSERT INTO EXAM_EMP VALUES(7208, 'TEST_USER8', 'STUDENT', 7201, '2018-03-09', 1200, NULL, 80);

ROLLBACK;

-- PPT 5장 실습문제 3
UPDATE EXAM_EMP 
SET DEPTNO = 70 
WHERE SAL > (SELECT AVG(SAL) FROM EXAM_EMP WHERE DEPTNO=50);

-- PPT 5장 실습문제 4
UPDATE EXAM_EMP
SET SAL = SAL * 1.1, DEPTNO = 80
WHERE HIREDATE > (SELECT MIN(HIREDATE) FROM EXAM_EMP WHERE DEPTNO = 60);

-- PPT 5장 실습문제 5
DELETE FROM EXAM_EMP
WHERE EMPNO IN (SELECT E.EMPNO 
                FROM EXAM_EMP E, EXAM_SALGRADE S
                WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 5);

COMMIT;


-- 트랜잭션 : 작업 수행의 최소 단위
-- commit(반영) / rollback(취소)
CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT;

-- DML 실행
INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';
SELECT * FROM DEPT_TCL;

ROLLBACK;

COMMIT;

-- 세션 : 어떤 활동을 위한 시간이나 기간
--       데이터베이스 접속을 시작으로 여러 데이터베이스에서 관련 작업을 수행한 후
--       접속을 종료하기 전까지 전체 기간
SELECT * FROM DEPT_TCL;

DELETE FROM DEPT_TCL WHERE DEPTNO = 50;
COMMIT;

UPDATE DEPT_TCL SET LOC = 'SEOUL'
WHERE DEPTNO = 30;

commit;

-- 데이터 정의어(DDL) : 여러 객체의 생성, 변경, 삭제 기능 제공
--                    Auto commit 구문
-- CREATE, ALTER, DROP

-- 테이블 생성
-- CREATE TABLE 테이블명(열1 이름 자료형, 열2 이름 자료형......);

-- 테이블 명 생성 규칙
-- 문자로 시작(영어, 한글, 숫자 0-9, 특수문자, $, _, # 가능)
-- 테이블명은 30BYTE 이하
-- 같은 사용자 소유의 데이블 이름은 중복 안됨
-- 키워드는 테이블명 사용 불가(SELECT, DELETE......)

CREATE TABLE EMP_DDL(
 EMPNO NUMBER(4),
 ENAME VARCHAR2(10), -- 문자 타입
 JOB VARCHAR2(9),
 MGR NUMBER(4),
 HIREDATE DATE,
 SAL NUMBER(7, 2), -- 전체 자릿수는 7자리인데 그 중 소수점 자릿수를 2자리로 하겠다
 COMM NUMBER(7, 2),
 DEPT NUMBER(2)
);

-- 문자 타입 : CHAR(10), NCHAR(10), VARCHAR2(10), NVARCHAR2(10)
-- N : 유니코드, V : Variable(가변)
-- CHAR : 고정길이 문자형
-- NCHAR : 유니코드 고정길이 문자형
-- VARCHAR2 : 가변길이 문자형
-- NVARCHAR2 : 유니코드 가변길이 문자형

CREATE TABLE TEST(
    ID NUMBER(4),
    NAME VARCHAR2(3));

DESC TEST;

-- value too large for column "SCOTT"."TEST"."NAME" (actual: 9, maximum: 3)
INSERT INTO TEST(ID, NAME) VALUES(10, '홍길동');
INSERT INTO TEST(ID, NAME) VALUES(10, 'LKG');

CREATE TABLE TEST2(
    ID NUMBER(4),
    NAME NCHAR(3)); -- 문자 그대로의 갯수를 의미(고정길이를 사용한다.)
    
INSERT INTO TEST2(ID, NAME) VALUES(10, '홍길동');
INSERT INTO TEST2(ID, NAME) VALUES(20, '박');

SELECT * FROM TEST2 WHERE NAME='박';

CREATE TABLE TEST3(
    ID NUMBER(4),
    NAME NVARCHAR2(3)); -- 문자 그대로의 갯수를 의미(가변길이를 사용한다.)
    
INSERT INTO TEST3(ID, NAME) VALUES(10, '홍길동');
INSERT INTO TEST3(ID, NAME) VALUES(20, '박');

CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;

CREATE TABLE DEPT_DDL_30 AS SELECT * FROM DEPT WHERE DEPTNO = 30;

CREATE TABLE DEPT_DDL2 AS SELECT * FROM DEPT WHERE 1<>1;

-- DROP : 삭제
DROP TABLE DEPT_DDL2;

-- ALTER : 수정

CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;
SELECT * FROM EMP_ALTER;

-- 테이블 컬럼 추가하기 : ADD
ALTER TABLE EMP_ALTER ADD HP VARCHAR2(20);

-- 열 이름 변경하기 : RENAME
ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;

-- 열 자료형이나 길이변경하기
ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
DESC EMP_ALTER;

-- 특정 열 삭제
ALTER TABLE EMP_ALTER DROP COLUMN TEL;

-- 테이블의 이름 변경 : RENAME
RENAME EMP_ALTER TO EMP_RENAME;
DESC EMP_RENAME;

-- PPT 6번 실습1
CREATE TABLE MEMBER(
    ID CHAR(8),
    NAME VARCHAR2(10), -- NVARCHAR2(3)
    ADDR VARCHAR2(50), -- NVARCHAR2(20)
    NATION NCHAR(4),
    EMAIL VARCHAR2(50),
    AGE NUMBER(7, 2)
);

-- PPT 6번 실습2 (1)
ALTER TABLE MEMBER ADD BIGO VARCHAR2(20);
-- PPT 6번 실습2 (2)
ALTER TABLE MEMBER MODIFY BIGO VARCHAR2(30);
-- PPT 6번 실습2 (3)
ALTER TABLE MEMBER RENAME COLUMN BIGO TO REMARK;
-- PPT 6번 실습3 (5)
UPDATE MEMBER SET REMARK=' ';
-- PPT 6번 실습3 (6)
DROP TABLE MEMBER;

-- PPT 6번 실습3 (4)
INSERT INTO MEMBER(ID, NAME, ADDR, NATION, EMAIL, AGE) 
            VALUES('hong1243', '홍길동', '서울시 구로구 개봉동', '대한민국', 'hong123@naver.com', 25);

DESC MEMBER;
SELECT * FROM MEMBER;


-- 데이터 사전 : DB를 구성하고 운영하는데 필요한 정보를 담는 특수한 테이블
--             직접 접근은 불가하고 뷰를 통해서 접근

SELECT * FROM DICT;

-- USER_ : 현재 오라클에 접속되어 있는 사용자가 소유한 객체 정보
-- SCOTT 계정이 가지고 있는 테이블 정보
SELECT * FROM USER_TABLES;

-- ALL_ : 다른 사용자가 소유한 객체 중 사용이 허락되어 있는 객체 정보
SELECT * FROM ALL_TABLES;

SELECT * FROM DBA_TABLES;

-- 인덱스(직접 생성 / 기본키(Primary key) OR 고유키(Unique)로 설정하면 자동으로 생성)
SELECT * FROM USER_INDEXES;

-- 직접 생성
CREATE INDEX IDX_EMP_SAL ON EMP(SAL);

SELECT * FROM EMP WHERE SAL = 1600;


-- 삭제
DROP INDEX IDX_EMP_SAL;

-- 인덱스 자동 생성
CREATE TABLE USERTBL(
    USERID CHAR(8) NOT NULL PRIMARY KEY,
    USERNAME NVARCHAR2(10) NOT NULL,
    BIRTHYEAR NUMBER(4) NOT NULL,
    MOBILE CHAR(3));

SELECT INDEX_NAME, UNIQUENESS, INDEX_TYPE FROM USER_INDEXES;

-- 뷰(VIEW) : 가상 테이블(SELECT문 저장)

-- 뷰 생성
-- insufficient privileges : 권한이 불충분하다.
CREATE VIEW VM_EMP20 
    AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);
    
SELECT * FROM VM_EMP20;
SELECT * FROM USER_VIEWS;

-- 뷰 삭제
DROP VIEW VM_EMP20;

-- 뷰에 데이터 입력? => 원본도 변경이 됨
INSERT INTO VM_EMP20 VALUES(7903, 'JAMES', 'MANAGER', 20);
SELECT * FROM VM_EMP20;
SELECT * FROM EMP;

-- 원본 데이터를 수정할 수 없도록 뷰 생성
CREATE VIEW VM_EMP_READ AS SELECT EMPNO, ENAME, JOB FROM EMP WITH READ ONLY;

SELECT * FROM VM_EMP_READ;
-- cannot perform a DML operation on a read-only view
INSERT INTO VM_EMP_READ VALUES(8000, '홍길동', 'ANALYST');

-- 인라인 뷰
SELECT ROWNUM , e.*
FROM EMP E;

-- 시퀀스 : 특정 규칙에 맞는 연속 숫자 생성
--         게시판 글 번호, 상품 주문 번호 생성 시 사용

-- 시퀀스 생성
-- WHERE 1<>1 : 구조만 복사한다.
CREATE TABLE DEPT_SEQUENCE AS SELECT * FROM DEPT WHERE 1<>1;
SELECT * FROM DEPT_SEQUENCE;

CREATE SEQUENCE SEQ_DEPT_SEQUENCE            -- 필수
INCREMENT BY 10 -- 기본값은 1                 -- 이 구문부터 아래까지는 선택
START WITH 10   -- 기본값은 1
MAXVALUE 90     -- 기본값은 10의 27승까지
MINVALUE 0      -- 시작값이하, 최댓값 미만 값, 기본값은 1
NOCYCLE         -- 시퀀스 생성값이 MAX 도달할 경우 반복 여부
CACHE 2;        -- 시퀀스 생성할 번호를 메모리에 미리 할당해 놓은 숫자.

INSERT INTO DEPT_SEQUENCE VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATA', 'SEOUL');
-- sequence SEQ_DEPT_SEQUENCE.NEXTVAL exceeds MAXVALUE and cannot be instantiated

-- 현재 시퀀스 값 확인
SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

ALTER SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 3
MAXVALUE 99
CYCLE;

DROP SEQUENCE SEQ_DEPT_SEQUENCE;


-- 다른 사용자에게 TEMP 테이블을 조회, 삽입할 수 있는 권한 부여

CREATE TABLE TEMP(
    COL1 VARCHAR2(20),
    COL2 VARCHAR2(20));

GRANT SELECT, INSERT ON TEMP TO TEST;

SELECT * FROM TEMP;

-- 권한 취소
REVOKE INSERT ON TEMP FROM TEST;

-- 데이터 무결성 
-- NOT NULL : NULL의 저장을 허용하지 않음
CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
); 

-- cannot insert NULL into
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID01', NULL, '010-1234-5678');

INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID01', 'TEST_PWD01', '010-1234-5678');

INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD)
VALUES('TEST_ID02', 'TEST_PWD02');

-- 제약조건 확인
SELECT * FROM USER_CONSTRAINTS;

-- 제약 조건 시 이름 지정
CREATE TABLE TABLE_NOTNULL2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBL_NN2_LOGID_NN NOT NULL,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBL_NN2_LOGPWD_NN NOT NULL,
    TEL VARCHAR2(20)
); 

-- 이미 생성된 테이블에 제약조건 추가
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL NOT NULL);
-- 이미 생성된 테이블에 제약조건 추가(제약조건명 포함)
ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL CONSTRAINT TBL_NN2_TEL_NN NOT NULL);
-- 이미 생성된 제약 조건명 변경하기
ALTER TABLE TABLE_NOTNULL2 RENAME CONSTRAINT SYS_C007014 TO TBL_NN2_TEL_NN;
-- 제약 조건 삭제
ALTER TABLE TABLE_NOTNULL2 DROP CONSTRAINT TBL_NN2_TEL_NN;

DESC TABLE_NOTNULL2;

-- UNIQUE : 저장할 데이터의 중복 안됨
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR2(20) UNIQUE,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
); 

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('hong123', 'hong123', '010-1234-1234');
-- unique constraint
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('hong123', 'hong123', '010-1234-1234');

CREATE TABLE TABLE_UNIQUE2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBL_UNQ_LGNID_UNQ UNIQUE,
    LOGIN_PWD VARCHAR2(20) CONSTRAINT TBL_UNQ_LGNPWD_UNQ NOT NULL,
    TEL VARCHAR2(20)
); 

-- PRIMARY KEY(기본값) : 유일하게 하나만 있는 값
CREATE TABLE TABLE_PK(
    LOGIN_ID VARCHAR2(20) PRIMARY KEY, -- NOT NULL + UNIQUE
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20));

DESC TABLE_PK;

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('hong123', 'hong123', '010-1234-1234');
-- unique constraint (SCOTT.SYS_C007042) violated
INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('hong123', 'hong123', '010-1234-1234');

-- 이름 지정
CREATE TABLE TABLE_PK2(
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBL_PK2_LOGID_PK PRIMARY KEY, -- NOT NULL + UNIQUE
    LOGIN_PWD VARCHAR2(20)CONSTRAINT TBL_PK2_LOGPWD_PK NOT NULL,
    TEL VARCHAR2(20));
    
-- 제약조건 모아서 주기(NOT NULL은 제외)
CREATE TABLE TABLE_CONSTRAINT(
    ID NUMBER(4),
    NAME VARCHAR2(10),
    ADDR VARCHAR2(20),
    TEL VARCHAR2(20),
    CONSTRAINT TBL_ID_PK PRIMARY KEY(ID),
    CONSTRAINT TBL_TEL_UNQ UNIQUE(TEL));

-- FOREIGN KEY(FK, 외래키) : 테이블간의 관계 설정
-- integrity constraint (SCOTT.FK_DEPTNO) violated - parent key not found
-- EMP 테이블의 DEPTNO값은 DEPT 테이블의 DEPTNO가 가지고 있는 값 범위 내에서만 가능
SELECT * FROM EMP;
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', SYSDATE, 1200, NULL, 50);

CREATE TABLE DEPT_FK(
    DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13));
    
CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7, 2),
    COMM NUMBER(7, 2),
    DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK EFERENCES DEPT_FK(DEPTNO));
    
-- 외래 키 지정 시 부모 테이블에 먼저 데이터 입력
INSERT INTO DEPT_FK VALUES(50, 'DATABASE', 'SEOUL');

INSERT INTO EMP_FK(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', SYSDATE, 1200, NULL, 50);

-- 외래키
-- integrity constraint (SCOTT.EMPFK_DEPTNO_FK) violated - child record found
DELETE FROM EMP_FK WHERE EMPNO=9999;
DELETE FROM DEPT_FK WHERE DEPTNO=50;

DROP TABLE EMP_FK;

-- 데이터 삭제 시 참조하는 데이터도 같이 삭제
CREATE TABLE EMP_FK(
    EMPNO NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7, 2),
    COMM NUMBER(7, 2),
    DEPTNO NUMBER(2) CONSTRAINT EMPFK_DEPTNO_FK EFERENCES DEPT_FK(DEPTNO)
    ON DELETE CASCADE -- 참조하는 데이터 같이 삭제
    );
-- ON DELETE SET NILL : 참조하는 데이터를 NULL로 수정

-- DEFAULT : 기본값 지정
CREATE TABLE TABLE_DEFAULT
    LOGIN_ID VARCHAR2(20) CONSTRAINT TBLCK2_LOGINID_PK PRIMARY KEY,
    LOGIN_PWD VAARCHAR2(20) DEFAULT '1234',
    TEL VARCHAR2(20)
);

INSERT INTO TABLE_DEFAULT(LOGIN_ID, TEL) CALUES('TEST', '010-1234-1234');

-- Q) DEPT_CONST 테이블 작성하기
--    열 이름 DEPTNO 정수형 숫자(2), PRIMARY KET, 제약 조건명 : DEPTCONST_DEPTNO_PK
--    열 이름 DNAME 가변병 문자열(14), UNIQUE, 제약 조건명 : DEPTCONST_DNAME_UNQ
--    열 이름 LOC 가변형 문자열(13), NOT NULL, 제약 조건명 : DEPTCONST_LOC_NN
CREATE TABLE DEPT_CONST(
    DEPTNO NUMBER(2) CONSTRAINT DEPTCONST_DEPTNO_PK PRIMARY KEY,
    DNAME VARCHAR2(14) CONSTRAINT DEPTCONST_DNAME_UNQ UNIQUE,
    LOC VARCHAR(13) CONSTRAINT DEPTCONST_LOC_NN NOT NULL);


-- Q) EMP_CONST 테이블 작성하기
-- EMPNO 정수형 숫자(4) PRIMARY KEY, 제약 조건명 : EMPCONST_EMPNO_PK
-- ENAME 가변형 문자열(10) NOT NULL, EMPCONST_ENAME_NN
-- JOB 가변형 문자열(9)
-- TEL 가변형 문자열(20), UNIQUE, EMPCONST_TEL_UNQ
-- HIREDATE 날짜
-- SAL 소수점 둘째자리 숫자(7)
-- DEPTNO 정수형 숫자(2) FOREIGN KEY, EMPCONST_DEPTNO_FK
CREATE TABLE EMP_CONST(
    EMPNO NUMBER(4) CONSTRAINT EMPCONST_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMPCONST_ENAME_NN NOT NULL,
    JOB VARCHAR2(9),
    TEL VARCHAR2(20) CONSTRAINT EMPCONST_TEL_UNQ UNIQUE,
    HIREDATE DATE,
    SAL NUMBER(7, 2),
    DEPTNO NUMBER(2) CONSTRAINT EMPCONST_DEPTNO_FK REFERENCES DEPT_CONST(DEPTNO));
    
SET SERVEROUTPUT ON;

DECLARE
    V_DEPTNO DEPT.DEPTNO%TYPE := 50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('DEPTNO : ' || V_DEPTNO);
END;
/

DECLARE
    V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
    SELECT DEPTNO, DNAME, LOC INTO V_DEPT_ROW
    FROM DEPT
    WHERE DEPTNO=40;
    DBMS_OUTPUT.PUT_LINE('DEPTNO : '||V_DEPT_ROW.DEPTNO);
    DBMS_OUTPUT.PUT_LINE('DNAME : '||V_DEPT_ROW.DNAME);
    DBMS_OUTPUT.PUT_LINE('LOC : '||V_DEPT_ROW.LOC);
END;
/

-- javadb에 권한 부여
GRANT SELECT, INSERT ON DEPT TO javadb;
