-- scott 소유의 모든 테이블 조회
select * from tab;

-- bonus 테이블의 모든 내용 조회
select * from bonus;

-- emp 테이블의 모든 내용 조회
select * from emp;

-- emp 테이블의 empno, ename 조회
select empno, ename from emp;

-- emp 테이블의 empno, job, hiredate 조회
select empno, job, hiredate from emp;

-- 중복된 값 제거 : DISTINCT
select deptno from emp;
select DISTINCT deptno from emp;

-- 별칭
select empno from emp;
select empno as 사원번호 from emp;
select empno 사원번호 from emp;
select empno "사원번호" from emp;
select empno as "사원번호" from emp;

SELECT enam, sal, sal*12 + comm, comm FROM emp;
SELECT enam, sal, sal*12 + comm AS 연봉, comm FROM emp;

-- ename(사원명), job(직책), 별칭을 붙은 후 emp 조회
select ename 사원명, job "직 책" from emp;
select ename as 사원명, job as "직 책" from emp;

-- 정렬 : ORDER BY 정렬하려는 열 이름 정렬 옵션(ASC(오름차순), DESC(내림차순))
-- ENAME, SAL 조회(SAL 내림차순)
select ename, sal from emp order by sal DESC;
select ename, sal from emp order by sal;

-- 전체 데이터 조회 시 SAL 내림차순
SELECT * FROM emp ORDER BY sal DESC;

-- EMPNO, ENAME, JOB을 조회할 때 EMPNO 오름차순
SELECT EMPNO, ENAME, JOB FROM emp ORDER BY EMPNO;
SELECT EMPNO, ENAME, JOB FROM emp ORDER BY EMPNO ASC;

-- 부서번호의 오름차순과 급여의 내림차순 정렬하기
select * from emp Order BY deptno ASC, sal DESC;

-- 조회할 테이블은 EMP 테이블이며 모든 열을 출력
-- 출력되는 열의 별칭을 다음과 같이 지정
-- EMPNO : EMPLOYEE_NO
-- ENAME : EMPLOYEE_NAME
-- MGR : EMPLOYEE_NAME
-- SAL : SALARY
-- COMM : COMMISSION
-- DEPTNO : DEPARTMENT_NO
-- 부서 번호를 기준으로 내림차순으로 정렬
-- 부서 번호가 같다면 사원 이름을 기준으로 오름차순 정렬


SELECT 
EMPNO AS EMPLOYEE_NO, ENAME AS EMPLOYEE_NAME, 
MGR AS EMPLOYEE_NAME, SAL AS SALARY, COMM AS COMMISSION, 
DEPTNO AS DEPARTMENT_NO  
FROM EMP ORDER BY DEPTNO DESC, ENAME ASC;

-- WHERE : 조건에 맞춰서 조회

-- 부서번호가 30번인 사원 조회
SELECT * FROM emp WHERE deptno = 30;

-- 사원번호가 7782인 사원 정보 조회
SELECT * FROM emp WHERE empno = 7782;

-- 부서번호가 30이고 사원 직책이 SALESMAN인 사원 조회
SELECT * FROM emp WHERE DEPTNO = 30 AND job = 'SALESMAN';

-- 부서번호가 30이거나 사원직책이 CLERK인 사원 조회
SELECT * FROM emp WHERE DEPTNO = 30 AND job = 'CLERKL';


-- 산술연산자 : * / + -

-- SAL*12의 값이 36000인 사원 조회
SELECT * FROM EMP WHERE SAL * 12 = 36000;

-- SAL의 값이 3000 이상인 사원 조회
SELECT * FROM EMP WHERE SAL >= 3000;

-- 급여가 2500이고, 직업이 ANALYST인 사원 조회
SELECT * FROM EMP WHERE SAL >= 2500 AND JOB = 'ANALYST';

-- 사원 이름의 첫문자가 F와 같거나 뒤쪽인 것만 조회(F, G, H, I ~~)
SELECT * FROM EMP WHERE ENAME >= 'F';

-- 직무가 MANAGER, SALESMAN, CLERK인 사원 조회
SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';

-- 등가 비교 연산자( = (동등), !=, <>, ^= )
-- SALㅇ; 3000이 아닌 사원정보 조회
SELECT * FROM EMP WHERE SAL != 3000;
SELECT * FROM EMP WHERE SAL ^= 3000;
SELECT * FROM EMP WHERE SAL <> 3000;

-- 논리 부정 연산자 : NOT
SELECT * FROM EMP WHERE NOT SAL = 3000;

-- IN은 =과 같은 개념이다.
SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
SELECT * FROM EMP WHERE JOB IN('MANAGER', 'SALESMAN', 'CLERK');

-- NOT IN
SELECT * FROM EMP WHERE JOB != 'MANAGER' AND JOB ^= 'SALESMAN' AND JOB <> 'CLERK';
SELECT * FROM EMP WHERE JOB NOT IN('MANAGER', 'SALESMAN', 'CLERK');

-- 부서번호가 10, 20 사원 조회(IN)
SELECT * FROM EMP WHERE DEPTNO = 10 OR DEPTNO = 20;
SELECT * FROM EMP WHERE DEPTNO IN(10, 20);

-- BETWEEN A AND B : 특정 범위의 데이터를 조회
SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000;
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;

-- SAL 2000이상 ~ 3000이하가 아닌 사원 조회
SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000;

-- LIKE 연산자와 와일드 카드
-- 와일드 카드 : _(어떤 문자든 한 개의 문자를 의미), %(길이와 상관없는 모든 문자를 의미)

-- 사원 이름이 S로 시작하는 사원 조회
SELECT * FROM EMP WHERE ENAME LIKE 'S%';

-- 사원 이름의 두번째 글자가 L인 사원 조회
SELECT * FROM EMP WHERE ENAME LIKE '_L%';

-- 사원 이름에 AM이 포함되어 있는 사원 조회
SELECT * FROM EMP WHERE ENAME LIKE '%AM%';

-- 사원 이름에 AM이 포함되어 있지 않은 사원
SELECT * FROM EMP WHERE ENAME NOT LIKE '%AM%';

-- IS NULL
-- NULL : 값이 존재하지 않음/ 해당사항 없음 / 확정되지 않은 값
SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE MGR IS NULL;
SELECT * FROM EMP WHERE NOT MGR IS NULL;
SELECT * FROM EMP WHERE MGR IS NOT NULL;

-- 집합 연산자 : 합집합 - UNION(중복된 값은 제거됨), UNION ALL, 차집합 - MINUS, 교집합 - INTERSECT

-- 10번 부서와 20번 부서 조회
SELECT * FROM EMP WHERE DEPTNO = 10
UNION
SELECT * FROM EMP WHERE DEPTNO = 20;

SELECT * FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT * FROM EMP WHERE DEPTNO = 20;

SELECT * FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT * FROM EMP
MINUS
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT * FROM EMP
INTERSECT
SELECT * FROM EMP WHERE DEPTNO = 10;

-- 20번, 30번 부서에 근무하고 있는 사원 중 급여가 2000 초과인 사원을 집합 연산자를
-- 사용해서 조회하기
SELECT * FROM EMP WHERE DEPTNO IN(20,30)
INTERSECT
SELECT * FROM EMP WHERE SAL > 2000;

SELECT * FROM EMP WHERE SAL > 2000
MINUS
SELECT * FROM EMP WHERE DEPTNO = 10;

SELECT * FROM EMP WHERE DEPTNO = 20 AND SAL > 2000 
UNION
SELECT * FROM EMP WHERE DEPTNO = 30 AND SAL > 2000 ;

-- 함수
-- 내장함수 : 오라클에서 기본으로 제공하는 함수
-- 사용자 정의 함수

-- 문자 함수 1) 대소문자
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME) FROM EMP;

-- ORACLE, oracle, Oracle => 입력값이 다양하다.
-- WHERE LOWER(TITLE) LIKE '%oracle%'

-- 문자 함수 2) 길이
-- LENGTHB : 바이트 수 확인
SELECT LENGTH('한글'), LENGTHB('한글') FROM DUAL;

-- ENAME 길이
SELECT ENAME, LENGTH(ENAME) FROM EMP;

-- ENAME 길이가 5 이상인 사원 조회
SELECT ENAME FROM EMP WHERE LENGTH(ENAME) >= 5;

-- 문자 함수 3) 문자열 추출
SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, 5) FROM EMP;

-- EMP 테이블의 모든 사원 이름을 세번째 글자부터 끝까지 출력하기
SELECT ENAME, SUBSTR(ENAME, 3) FROM EMP;

-- 문자 함수 4) 특정 문자의 위치
SELECT INSTR('HELLO, ORACLE!', 'L') AS 첫번째, INSTR('HELLO, ORACLE!', 'L', 5) AS 두번째,
INSTR('HELLO, ORACLE!', 'L', 2, 2) AS 세번째 FROM DUAL;

SELECT INSTR('이것이 Oracle이다. 이것도 오라클이다', '이것') FROM DUAL;
SELECT INSTR('이것이 Oracle이다. 이것도 오라클이다', '이것', 2) FROM DUAL;
SELECT INSTRB('이것이 Oracle이다. 이것도 오라클이다', '이것', 2) FROM DUAL;

-- 사원 이름에 S가 있는 사원 조회
SELECT * FROM EMP WHERE INSTR(ENAME, 'S') > 0;

-- 문자 함수 5) 문자열 대체
SELECT REPLACE('이것이 Oracle이다', '이것', 'This is') FROM DUAL;

-- 010-1234-5678, 010 1234 5678, 01012345678
SELECT '010-1234-5678', REPLACE('010-1234-5678', '-', ' '), REPLACE('010-1234-5678', '-', '') FROM DUAL;

-- 문자 함수 6) 문자열 연결
SELECT CONCAT(EMPNO, ENAME), CONCAT(EMPNO, CONCAT(':', ENAME))
FROM EMP WHERE ENAME = 'SMITH';

--CONCAT() ==  ||
SELECT EMPNO || ENAME, EMPNO || ':' || ENAME
FROM EMP WHERE ENAME = 'SMITH';

-- 문자 함수 7) 특정 문자 제거 - TRIM, LTRIM, RTRIM
SELECT '  이것이   ', TRIM('   이것이   ') FROM DUAL;

SELECT '[' || TRIM('  __ORACLE__  ') || ']' as TRIM,
'[' || LTRIM('  __ORACLE__  ') || ']' as LTRIM,
'[' || RTRIM('  __ORACLE__  ') || ']' as RTRIM
FROM DUAL;

-- 문자 함수 8) 문자열을 반대로 처리
SELECT REVERSE('ORACLE') FROM DUAL;

-- 숫자함수 : 반올림 / 올림 / 버림 / 나머지 값
-- 반올림
SELECT ROUND(1234.5678) AS ROUND, ROUND(1234.5678, 0) AS ROUND0, 
ROUND(1234.5678, 1) AS ROUND1, ROUND(1234.5678, 2) AS ROUND2,
ROUND(1234.5678, -1) AS ROUND_MINUS1, ROUND(1234.5678, -2) AS ROUND_MINUS2
FROM DUAL;

-- 버림
SELECT TRUNC(1234.5678) AS TRUNC, TRUNC(1234.5678, 0) AS TRUNC0, 
TRUNC(1234.5678, 1) AS TRUNC1, TRUNC(1234.5678, 2) AS TRUNC2,
TRUNC(1234.5678, -1) AS TRUNC_MINUS1, TRUNC(1234.5678, -2) AS TRUNC_MINUS2
FROM DUAL;

-- 지정한 숫자와 가장 가까운 정수를 찾는 CEIL(큰 정수), FLOOR(작은 정수)
SELECT CEIL(3.14), FLOOR(3.14), CEIL(-3.14), FLOOR(-3.14)
FROM DUAL;

-- 나머지
SELECT MOD(15, 6), MOD(10, 2), MOD(11, 2)
FROM DUAL;

-- 날짜 함수 : SYSDATE(오라클 서버가 설치된 OS 현재 날짜와 시간)
SELECT SYSDATE FROM DUAL;

SELECT SYSDATE AS NOW, SYSDATE-1 AS YESTERDAY, SYSDATE+1 AS TOMORROW FROM DUAL;

-- 몇 개월 이후의 날짜 구하기 : ADD_MONTHS
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3) FROM DUAL;

-- 입사 10주년이 되는 날짜 구하기
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 120) FROM EMP;

-- 현재 날짜 기준으로 입사 38년 미만인 사원 조회
SELECT * FROM EMP WHERE ADD_MONTHS(HIREDATE, 540) > SYSDATE;

-- 두 날짜 자시이의 차이 : MONTHS_BETWEEN
SELECT * FROM EMP WHERE MONTHS_BETWEEN(SYSDATE, HIREDATE) < 540;

SELECT EMPNO, ENAME, HIREDATE, SYSDATE, MONTHS_BETWEEN(HIREDATE, SYSDATE) AS MONTHS,
MONTHS_BETWEEN(SYSDATE, HIREDATE) AS MONTHS2, TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTH3
FROM EMP;

-- 돌아오는 요일(NEXT_DAY), 달의 마지막 날짜(LAST_DAY)
SELECT SYSDATE, NEXT_DAY(SYSDATE, '월요일'), LAST_DAY(SYSDATE) FROM DUAL;

-- 자료형 변환 함수
-- 1) TO_CHAR() : 날짜, 숫자 데이터를 문자로 변환
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD') AS 현재날짜 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'MM') AS 현재월 FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MON') AS 현재월 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD') AS 현재일자 FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'DAY') AS 현재일자 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'HH:MI:SS') AS 현재시간 FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'HH12:MI:SS') AS 현재시간 FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'HH24:MI:SS') AS 현재시간 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'HH:MI:SS PM') AS 현재시간 FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH:MI:SS PM') AS 현재시간 FROM DUAL;

-- TO_NUMBER() : 문자를 숫자 데이터 형식으로 변환
SELECT 1300-'1500', '1300'+1500 FROM DUAL;

SELECT 1300-TO_NUMBER('1500'), TO_NUMBER('1300')+1500 FROM DUAL;

-- invalid number
-- SELECT 1300-'1500', '1300'+1500 FROM DUAL;
-- SELECT 1300-TO_NUMBER('1500'), TO_NUMBER('1300')+1500 FROM DUAL;
-- ,는 받지 않는다.
SELECT 1300-TO_NUMBER('1,500', '999,999'), TO_NUMBER('1,300', '999,999')+1500 FROM DUAL;

-- TO_DATE() : 문자 데이터를 날짜형 데이터로 변환
SELECT TO_DATE('2021-04-16') AS TDOATE1, TO_DATE('20210416') AS TODATE2 FROM DUAL;
SELECT TO_DATE('2021-04-16') - TO_DATE('2021-04-12') FROM DUAL;

-- 널처리 함수 : NVL(), NVL2(), 
SELECT EMPNO, ENAME, SAL, COMM, SAL + COMM FROM EMP;
SELECT EMPNO, ENAME, SAL, COMM, SAL + NVL(COMM, 0) FROM EMP;

-- NVL2(널 열, 널이 아닐 경우 반환할 값, 널일 경우 반환할 값)
SELECT EMPNO, ENAME, SAL, COMM, 
    NVL2(COMM, 'O', 'X'), SAL + NVL2(COMM, SAL * 12 + COMM, SAL * 12)
FROM EMP;

-- DECODE 함수
SELECT EMPNO, ENAME, JOB, SAL, 
    DECODE(JOB, 'MANAGER', SAL * 1.1, 
                'SALESMAN', SAL * 1.05, 
                'ANALYST', SAL, SAL * 1.03) 
    AS UPSAL
FROM EMP;

-- CASE(DECODE 범용성이 높다)
SELECT EMPNO, ENAME, JOB, SAL, 
    CASE JOB 
        WHEN 'MANAGER' THEN SAL * 1.1 
        WHEN 'SALESMAN' THEN SAL * 1.05 
        WHEN 'ANALYST' THEN SAL ELSE SAL * 1.03 
        END AS UPSAL
FROM EMP;

SELECT EMPNO, ENAME, JOB, SAL, 
    CASE
        WHEN COMM IS NULL THEN '해당사항 없음'
        WHEN COMM = 0 THEN '수당 없음'
        WHEN COMM >0 THEN '수당 : ' || COMM
    END AS COMM_TEXT FROM EMP;


-- 실습문제(ORACLE PPT 18번부터) 1번
SELECT EMPNO, ENAME, SAL, 
    TRUNC(SAL/21.5, 2) AS DAY_PAY, 
    ROUND(SAL/(21.5*8), 1) AS TIME_PAY 
FROM EMP;


-- 실습문제 2번
SELECT EMPNO, ENAME, HIREDATE, NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일') AS R_JOB,
-- NVL(COMM, 'N/A') AS COMM FROM EMP;
-- invalid number가 뜨면서 안됨.
-- 현재 배열엔 숫자가 담겨있는데 N/A라는 문자를 담으려해서 에러가 남
-- 'N/A'가 문자이므로 COMM을 문자로 바꿔야한다.
    NVL(TO_CHAR(COMM), 'N/A') AS COMM 
FROM EMP;

-- NVL2 버전
SELECT EMPNO, ENAME, HIREDATE, NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일') AS R_JOB,
    NVL2(COMM, TO_CHAR(COMM), 'N/A') AS COMM 
FROM EMP;

-- CASE 버전
SELECT EMPNO, ENAME, HIREDATE, NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일') AS R_JOB,
    CASE
        WHEN COMM IS NULL THEN 'N/A'
        WHEN COMM IS NOT NULL THEN TO_CHAR(COMM)
    END AS COMM
FROM EMP;


-- 실습문제 3번
SELECT EMPNO, ENAME, MGR, 
    DECODE(SUBSTR(TO_CHAR(MGR), 1, 2),
        NULL, '0000',
        '75', '5555',
        '76', '6666',
        '77', '7777',
        '78', '8888',
        SUBSTR(TO_CHAR(MGR), 1))
    AS CHG_MGR 
FROM EMP;

-- CASE 버전
SELECT EMPNO, ENAME, MGR, 
    CASE 
        WHEN MGR IS NULL THEN '0000'
        WHEN SUBSTR(TO_CHAR(MGR), 1, 2) = '75' THEN '5555'
        WHEN SUBSTR(TO_CHAR(MGR), 1, 2) = '76' THEN '6666'
        WHEN SUBSTR(TO_CHAR(MGR), 1, 2) = '77' THEN '7777'
        WHEN SUBSTR(TO_CHAR(MGR), 1, 2) = '78' THEN '8888'
        ELSE TO_CHAR(MGR)
    END AS CHG_MGR 
FROM EMP;


-- 다중행 함수 : SUM, COUNT, MAX, MIN
SELECT SUM(COMM) FROM EMP;
SELECT COUNT(*) FROM EMP;
SELECT COUNT(*) FROM EMP WHERE DEPTNO = 30;
SELECT COUNT(SAL) FROM EMP;
SELECT COUNT(DISTINCT SAL), COUNT(SAL) FROM EMP;
SELECT MAX(SAL), MIN(ASL) FROM EMP;

-- 부서 번호가 
SELECT MIN(HIREDATE) FROM EMP WHERE DEPTNO = 20;

SELECT AVG(SAL) FROM EMP;

-- GROUP BY : 결과 값을 원하는 열로 묶어 출력
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO;

-- 부서번호, 직책별 평균 급여 구하기
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO, JOB;

-- 각 부서의 직책별 평균 급여를 구하되, 평균 급여가 2000이상인 그룹 출력
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

-- 부서별 직책의 평균 급여가 500 이사인 사원들의 부서번호, 직책, 부서별 직책의 평균 급여 조회
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP 
GROUP BY DEPTNO, JOB HAVING AVG(SAL) >= 500
ORDER BY DEPTNO, JOB;

--group function is not allowed here
--SELECT DEPTNO, JOB, AVG(SAL) FROM EMP 
--WHERE AVG(SAL) >= 500
--ORDER BY DEPTNO, JOB;

-- 부서번호, 평균급여, 최고급여, 사원수 출력하기
-- 단 ,평균 급여를 출력할 때 소수점을 제외하고 각 부서별로 출력
SELECT DEPTNO, FLOOR(AVG(SAL)), MAX(SAL), COUNT(ENAME) 
FROM EMP GROUP BY DEPTNO;

-- 같은 직책에 종사하는 사원이 3명 이상인 직책과 인원수 출력
SELECT JOB, COUNT(*) FROM EMP GROUP BY JOB HAVING COUNT(JOB) >= 3;

-- 사원들의 입사연도를 기본으로 부서별로 몇명인지 출력
SELECT DEPTNO, TO_CHAR(HIREDATE,'YYYY') AS 입사연도, COUNT(*) 
FROM EMP GROUP BY DEPTNO, TO_CHAR(HIREDATE,'YYYY');

SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP 
GROUP BY DEPTNO, JOB HAVING AVG(SAL) >= 2000 ORDER BY DEPTNO, JOB;

SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP  WHERE SAL <= 3000
GROUP BY DEPTNO, JOB HAVING AVG(SAL) >= 2000 ORDER BY DEPTNO, JOB;

-- JOIN
-- 등가조인(INNER JOIN(내부조인), 단순조인)
SELECT * FROM DEPT;
SELECT * FROM EMP;

-- column ambiguously defined
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- 문장이 길어 별칭으로 만든 후 처리
SELECT EMPNO, ENAME, E.DEPTNO, DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;


-- EMP 테이블의 DEPTNO와 DEPT 테이블의 DEPTNO가 일치하는 사원들의
-- 사원번호, 이름, 부서번호, 부서명 조회(단, 급여가 3000 이상인 사원 출력)
SELECT EMPNO, ENAME, EMP.DEPTNO, DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND SAL >= 3000;

-- EMP 테이블 별칭을 E로, DEPT 테이블 별칭을 D로 하여 급여가 2500 이상이고
-- 사원번호가 9999 이하인 사원들의 정보 출력
-- EMPNO, ENAME, SAL, DEPTNO, DNAME, LOC를 출력
SELECT EMPNO, ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.SAL >= 2500 AND E.EMPNO <= 9999;


-- EMP 테이블 별칭을 E로, SALGRADE 테이블 별칭을 S로 하여 
-- 각 사원의 정보와 사원의 급여 등급 정보를 출력하기
SELECT * FROM SALGRADE;

-- 비등가 조인
SELECT *
FROM EMP E, SALGRADE S
WHERE SAL BETWEEN S.LOSAL AND S.HISAL;

-- 자체조인(SELF JOIN) : 조인을 할 때 두번째 테이블이 자기 자신
SELECT * FROM EMP;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

-- 외부조인
-- 왼쪽 외부 조인 WHERE TABLE1.COL1 = TABLE2.COL(+)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

-- 오른쪽 외부 조인 WHERE TABLE1.COL1(+) = TABLE2.COL
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

-- + 기호를 붙이는 외부 조인 방식은 전체 외부 조인 구현 불가
--SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
--FROM EMP E1, EMP E2
--WHERE E1.MGR(+) = E2.EMPNO(+);

-- 표준문법 조인

-- NATURAL JOIN(등가조인)
SELECT E.EMPNO, E.ENAME, DEPTNO, D.DNAME
FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO;


-- JOIN ~ ON
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO
ORDER BY DEPTNO, E.EMPNO;


-- 표준 JOIN 문
-- OUTER JOIN ~ ON
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO ORDER BY E1.EMPNO;



-- 각 부서별 평균(급여), 최대(급여), 최소(급여), 사원수를 출력하가ㅣ
-- 단, 부서번호, 부서명, 평균, 최대, 최소, 사원수 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;

-- 표준 버전
SELECT D.DEPTNO, D.DNAME, FLOOR(AVG(E.SAL)), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;


-- 모든 부서정보와 사원 정보를 부서번호, 부서명, 사원번호, 사원명, 직무, 급여 형태로 출력
-- EMP 테이블과 DEPT 테이블 조인
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL 
FROM DEPT D LEFT OUTER JOIN EMP E 
ON D.DEPTNO = E.DEPTNO;


-- 급여가 2천 초과인 사원들의 부서 정보, 사원정보를 출력하기(SQL 표준 문법으로 작성)
-- 부서번호, 부서명, 사원번호, 사원명, 급여 순으로 출력
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D ON E.SAL > 2000;

